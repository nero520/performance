/**
 * 直接选择排序的
 * 基本操作就是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完，它需要经过n-1趟比较。算法不稳定，O(1)的额外的空间，比较的时间复杂度为O(n^2)，交换的时间复杂度为O(n)，并不是自适应的。在大多数情况下都不推荐使用。只有在希望减少交换次数的情况下可以用。
 基本思想
 n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果：
 ①初始状态：无序区为R[1..n]，有序区为空。
 ②第1趟排序
 在无序区R[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使R[1..1]和R[2..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。
 ……
 ③第i趟排序
 第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R(1≤i≤n-1)。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。
 这样，n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果。

 * @author xiaoxiong
 */
package com.performace.algorithm.sort.inner.select.direct;