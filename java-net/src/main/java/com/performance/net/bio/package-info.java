package com.performance.net.bio;
/**
 BIO：
 在JDK1.4出来之前，我们建立网络连接的时候采用BIO模式，需要先在服务端启动一个ServerSocket，
 然后在客户端启动Socket来对服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，
 而客户端发送请求后，先咨询服务端是否有线程相应，如果没有则会一直等待或者遭到拒绝请求，
 如果有的话，客户端会线程会等待请求结束后才继续执行。

 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，
 如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。

 BIO优缺点：
 优点
 模型简单
 编码简单
 缺点
 性能瓶颈低

 优缺点很明显。
 这里主要说下缺点：主要瓶颈在线程上。
 每个连接都会建立一个线程。
 虽然线程消耗比进程小，但是一台机器实际上能建立的有效线程有限，
 以Java来说，1.5以后，一个线程大致消耗1M内存！
 且随着线程数量的增加，CPU切换线程上下文的消耗也随之增加，在高过某个阀值后，继续增加线程，性能不增反降！
 而同样因为一个连接就新建一个线程，所以编码模型很简单！
 就性能瓶颈这一点，就确定了BIO并不适合进行高性能服务器的开发！
 像Tomcat这样的Web服务器，从7开始就从BIO改成了NIO，来提高服务器性能！



 1、收到一个请求就处理,这个时候就不能处理新的请求,这种为阻塞 这个是单线程模型,无法并发,一个请求没处理完服务器就会阻塞,不会处理下一个请求。一般的服务器不会使用这种方式实现。

 2、收到一个请求就新开一个线程去处理任务,主线程返回,继续处理下一个任务,这种为非阻塞 首先纠正一个错误,这并不是非阻塞,它也是阻塞的。相对第一个模型来说,它解决了主线程阻塞的问题,有了一定程度的并发量,但是在每个新开的线程中还是阻塞的。如果100个人同时访问,将会开100个线程,那1000个人,10000个人呢?频繁开关线程很消耗资源,这样实现的服务器性能依然不高。

 除了上面的两种方式,接下来的说说其他更好的方式:

 3、类似2的模型,但是不是每次收到请求就开一个新的线程,而是使用线程池 如果不了解线程池,你可能会了解数据库连接池,由于频繁创建、
 关闭数据库连接会消耗资源,所以会用数据库连接池来保存一定数量的连接,如果需要就从连接池里取连接,不需要则放回连接池,不在频繁创建。
 线程池也是一样的道理,线程池管理多线程,性能比频繁创建线程高得多。这种方式实现的服务器性能会比2高。不过,它依然是阻塞的。
 线程池的线程数量通常有限制的,如果所有线程都被阻塞(例如网速慢,或者被人恶意占用连接),那么接下来的请求将会排队等待。
 */